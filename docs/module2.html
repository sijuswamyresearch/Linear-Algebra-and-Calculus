<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.31">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>3&nbsp; Module-2: Matrix Eigen Value Problems – Linear Algebra and Calculus</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./module3.html" rel="next">
<link href="./module1.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-e1a5c8363afafaef2c763b6775fbf3ca.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-364982630eef5352dd1537128a8ed5cb.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./module2.html"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Module-2: Matrix Eigen Value Problems</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Linear Algebra and Calculus</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introduction to Linear ALgebra and Calculus</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./module1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Module-1: Linear Systems, Properties, and its Solution</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./module2.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Module-2: Matrix Eigen Value Problems</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./module3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Module 3: Multivariable Calculus - Differentiation</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./module4.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Module 4- Multi-variable Calculus- Integration</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./module5.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Module 5- Series Representation of Functions</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./summary.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Summary</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#the-big-question-what-does-a-matrix-do" id="toc-the-big-question-what-does-a-matrix-do" class="nav-link active" data-scroll-target="#the-big-question-what-does-a-matrix-do"><span class="header-section-number">3.1</span> The Big Question: What Does a Matrix <em>Do</em>?</a></li>
  <li><a href="#finding-eigenvalues-and-eigenvectors" id="toc-finding-eigenvalues-and-eigenvectors" class="nav-link" data-scroll-target="#finding-eigenvalues-and-eigenvectors"><span class="header-section-number">3.2</span> Finding Eigenvalues and Eigenvectors</a>
  <ul class="collapse">
  <li><a href="#example-a-symbolic-approach" id="toc-example-a-symbolic-approach" class="nav-link" data-scroll-target="#example-a-symbolic-approach"><span class="header-section-number">3.2.1</span> Example: A Symbolic Approach</a></li>
  <li><a href="#key-properties-of-eigenvalues" id="toc-key-properties-of-eigenvalues" class="nav-link" data-scroll-target="#key-properties-of-eigenvalues"><span class="header-section-number">3.2.2</span> Key Properties of Eigenvalues</a></li>
  <li><a href="#example-finding-eigenvectors-by-hand" id="toc-example-finding-eigenvectors-by-hand" class="nav-link" data-scroll-target="#example-finding-eigenvectors-by-hand"><span class="header-section-number">3.2.3</span> Example: Finding Eigenvectors by Hand</a></li>
  </ul></li>
  <li><a href="#the-geometry-of-eigenvectors" id="toc-the-geometry-of-eigenvectors" class="nav-link" data-scroll-target="#the-geometry-of-eigenvectors"><span class="header-section-number">3.3</span> The Geometry of Eigenvectors</a></li>
  <li><a href="#tutorial-3--eigen-values-and-eigen-vectors-in-engineering-applications" id="toc-tutorial-3--eigen-values-and-eigen-vectors-in-engineering-applications" class="nav-link" data-scroll-target="#tutorial-3--eigen-values-and-eigen-vectors-in-engineering-applications"><span class="header-section-number">3.4</span> Tutorial 3- Eigen values and Eigen vectors in Engineering Applications</a>
  <ul class="collapse">
  <li><a href="#questions" id="toc-questions" class="nav-link" data-scroll-target="#questions"><span class="header-section-number">3.4.1</span> Questions</a></li>
  <li><a href="#solutions" id="toc-solutions" class="nav-link" data-scroll-target="#solutions"><span class="header-section-number">3.4.2</span> Solutions</a></li>
  </ul></li>
  <li><a href="#diagonalization-of-a-matrix" id="toc-diagonalization-of-a-matrix" class="nav-link" data-scroll-target="#diagonalization-of-a-matrix"><span class="header-section-number">3.5</span> Diagonalization of a Matrix</a>
  <ul class="collapse">
  <li><a href="#example-verifying-diagonalization" id="toc-example-verifying-diagonalization" class="nav-link" data-scroll-target="#example-verifying-diagonalization"><span class="header-section-number">3.5.1</span> Example: Verifying Diagonalization</a></li>
  </ul></li>
  <li><a href="#symmetric-and-orthogonal-matrices" id="toc-symmetric-and-orthogonal-matrices" class="nav-link" data-scroll-target="#symmetric-and-orthogonal-matrices"><span class="header-section-number">3.6</span> Symmetric and Orthogonal Matrices</a></li>
  <li><a href="#application-quadratic-forms" id="toc-application-quadratic-forms" class="nav-link" data-scroll-target="#application-quadratic-forms"><span class="header-section-number">3.7</span> Application: Quadratic Forms</a></li>
  <li><a href="#tutorial-4-principal-axis-transformation-of-quadratic-forms" id="toc-tutorial-4-principal-axis-transformation-of-quadratic-forms" class="nav-link" data-scroll-target="#tutorial-4-principal-axis-transformation-of-quadratic-forms"><span class="header-section-number">3.8</span> Tutorial 4: Principal Axis Transformation of Quadratic Forms</a></li>
  <li><a href="#module-ii-summary" id="toc-module-ii-summary" class="nav-link" data-scroll-target="#module-ii-summary"><span class="header-section-number">3.9</span> Module II Summary</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Module-2: Matrix Eigen Value Problems</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<blockquote class="blockquote">
<p><strong>Syllabus:</strong> Eigen values and Eigen vectors - Properties of Eigen values - Diagonalization of matrices - Orthogonal transformation and orthogonal matrices - Quadratic forms and their Canonical forms.</p>
</blockquote>
<section id="the-big-question-what-does-a-matrix-do" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="the-big-question-what-does-a-matrix-do"><span class="header-section-number">3.1</span> The Big Question: What Does a Matrix <em>Do</em>?</h2>
<p>In the first module, we treated matrices as simple containers for the numbers in a linear system. But a matrix is much more than that. A matrix is a <em>transformation</em>. It takes a vector and maps it to a new vector.</p>
<p>When you multiply a vector <span class="math inline">\(x\)</span> by a matrix <span class="math inline">\(A\)</span>, the resulting vector <span class="math inline">\(Ax\)</span> is usually stretched and rotated. It points in a new direction.</p>
<p>But for any given matrix, there are a few very special vectors. When you multiply these special vectors by the matrix, they <strong>do not change direction</strong>. They only get stretched or shrunk. The output vector <span class="math inline">\(Ax\)</span> is parallel to the input vector <span class="math inline">\(x\)</span>.</p>
<p>These special vectors are the <strong>eigenvectors</strong> of the matrix, and the scaling factor is the <strong>eigenvalue</strong>.</p>
<blockquote class="blockquote">
<p><strong>Definition: Eigenvalue and Eigenvector</strong> For a square matrix <span class="math inline">\(A\)</span>, a non-zero vector <span class="math inline">\(x\)</span> is an eigenvector if it satisfies the equation: <span class="math display">\[ Ax = \lambda x \]</span> where <span class="math inline">\(\lambda\)</span> is a scalar known as the eigenvalue corresponding to the eigenvector <span class="math inline">\(x\)</span>.</p>
</blockquote>
<p>The eigenvectors tell you the “axes” of the transformation, the directions that are preserved. The eigenvalues tell you the scaling factor along those axes. If you know the eigenvalues and eigenvectors of a matrix, you understand its fundamental behavior.</p>
</section>
<section id="finding-eigenvalues-and-eigenvectors" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="finding-eigenvalues-and-eigenvectors"><span class="header-section-number">3.2</span> Finding Eigenvalues and Eigenvectors</h2>
<p>How do we find these special numbers <span class="math inline">\(\lambda\)</span> and vectors <span class="math inline">\(x\)</span>? We start by rewriting the main equation.</p>
<p><span class="math display">\[
\begin{align*}
Ax &amp;= \lambda x \\
Ax - \lambda x &amp;= 0 \\
Ax - \lambda I x &amp;= 0 &amp;&amp; \text{(where I is the identity matrix)} \\
(A - \lambda I)x &amp;= 0
\end{align*}
\]</span></p>
<p>Look at that last line! It’s a homogeneous system of equations, just like we saw in Module I. We are looking for a <em>non-zero</em> solution for <span class="math inline">\(x\)</span>. For the system <span class="math inline">\((A - \lambda I)x = 0\)</span> to have a non-trivial solution, the matrix <span class="math inline">\((A - \lambda I)\)</span> must be <strong>singular</strong>.</p>
<p>And what does it mean for a matrix to be singular? Its determinant must be zero.</p>
<blockquote class="blockquote">
<p><strong>The Characteristic Equation</strong> <span class="math display">\[ \det(A - \lambda I) = 0 \]</span></p>
</blockquote>
<p>Solving this equation for <span class="math inline">\(\lambda\)</span> gives us the eigenvalues. Then, for each eigenvalue, we plug it back into <span class="math inline">\((A - \lambda I)x = 0\)</span> to find the corresponding eigenvector(s).</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Shortcut for finding eigen values of 2x2 Matrices
</div>
</div>
<div class="callout-body-container callout-body">
<p>For any 2x2 matrix <span class="math inline">\(A = \begin{bmatrix} a &amp; b \\ c &amp; d \end{bmatrix}\)</span>, the characteristic equation is always: <span class="math display">\[ \lambda^2 - (\text{trace}(A))\lambda + \det(A) = 0 \]</span> Where:</p>
<ul>
<li><p>The <strong>trace</strong> is the sum of the diagonal elements: <span class="math inline">\(\text{trace}(A) = a+d\)</span>.</p></li>
<li><p>The <strong>determinant</strong> is <span class="math inline">\(\det(A) = ad-bc\)</span>.</p></li>
</ul>
<p>This is a beautiful and powerful result! You don’t need to calculate <span class="math inline">\(\det(A - \lambda I)\)</span> from scratch; just find the trace and determinant and plug them into the quadratic formula.</p>
</div>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Shortcut for finding eigen values of 3x3 Matrices
</div>
</div>
<div class="callout-body-container callout-body">
<p>A similar, though more complex, shortcut exists for 3x3 matrices. The characteristic equation is: <span class="math display">\[ \lambda^3 - (\text{trace}(A))\lambda^2 + C\lambda - \det(A) = 0 \]</span> Where <span class="math inline">\(C\)</span> is the sum of the determinants of the 2x2 principal minors (the matrices you get by deleting the <span class="math inline">\(i\)</span>-th row and <span class="math inline">\(i\)</span>-th column). <span class="math display">\[ C = \det\begin{pmatrix} a_{22} &amp; a_{23} \\ a_{32} &amp; a_{33} \end{pmatrix} + \det\begin{pmatrix} a_{11} &amp; a_{13} \\ a_{31} &amp; a_{33} \end{pmatrix} + \det\begin{pmatrix} a_{11} &amp; a_{12} \\ a_{21} &amp; a_{22} \end{pmatrix} \]</span> While this formula works, solving a cubic equation can be difficult, and this is where numerical methods often become more practical.</p>
</div>
</div>
<section id="example-a-symbolic-approach" class="level3" data-number="3.2.1">
<h3 data-number="3.2.1" class="anchored" data-anchor-id="example-a-symbolic-approach"><span class="header-section-number">3.2.1</span> Example: A Symbolic Approach</h3>
<p>Let’s do this for a simple matrix <span class="math inline">\(A = \begin{bmatrix} 4 &amp; -2 \\ 1 &amp; 1 \end{bmatrix}\)</span> using <code>SymPy</code> to see all the steps.</p>
<div id="find-eigenvalues-symbolic" class="cell" data-execution_count="1">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> sympy <span class="im">as</span> sp</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Define our matrix A</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> sp.Matrix([</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">4</span>, <span class="op">-</span><span class="dv">2</span>],</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">1</span>,  <span class="dv">1</span>]</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>])</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a symbol for lambda</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>lam <span class="op">=</span> sp.symbols(<span class="st">'lambda'</span>)</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Create the Identity matrix of the same size as A</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>I <span class="op">=</span> sp.eye(A.shape[<span class="dv">0</span>])  <span class="co"># Corrected</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Form the matrix (A - lambda*I)</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>char_matrix <span class="op">=</span> A <span class="op">-</span> lam <span class="op">*</span> I</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"The matrix (A - λI):"</span>)</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>sp.pprint(char_matrix)</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate the determinant to get the characteristic polynomial</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>char_poly <span class="op">=</span> char_matrix.det()</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">The characteristic polynomial det(A - λI) is: </span><span class="sc">{</span>char_poly<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a><span class="co"># Solve the characteristic equation det(A - λI) = 0 for the eigenvalues</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>eigenvalues <span class="op">=</span> sp.solve(char_poly, lam)</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">The eigenvalues are: </span><span class="sc">{</span>eigenvalues<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a><span class="co"># SymPy can also do this in one step</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">--- Using SymPy's built-in function ---"</span>)</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>sp.pprint(A.eigenvects())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>The matrix (A - λI):
⎡4 - λ   -2  ⎤
⎢            ⎥
⎣  1    1 - λ⎦

The characteristic polynomial det(A - λI) is: lambda**2 - 5*lambda + 6

The eigenvalues are: [2, 3]

--- Using SymPy's built-in function ---
⎡⎛      ⎡⎡1⎤⎤⎞  ⎛      ⎡⎡2⎤⎤⎞⎤
⎢⎜2, 1, ⎢⎢ ⎥⎥⎟, ⎜3, 1, ⎢⎢ ⎥⎥⎟⎥
⎣⎝      ⎣⎣1⎦⎦⎠  ⎝      ⎣⎣1⎦⎦⎠⎦</code></pre>
</div>
</div>
<p>The output shows that for our matrix <span class="math inline">\(A\)</span>, the eigenvalues are <span class="math inline">\(\lambda_1 = 3\)</span> and <span class="math inline">\(\lambda_2 = 2\)</span>. The corresponding eigenvectors are multiples of <span class="math inline">\(\begin{bmatrix} 2 \\ 1 \end{bmatrix}\)</span> and <span class="math inline">\(\begin{bmatrix} 1 \\ 1 \end{bmatrix}\)</span>.</p>
</section>
<section id="key-properties-of-eigenvalues" class="level3" data-number="3.2.2">
<h3 data-number="3.2.2" class="anchored" data-anchor-id="key-properties-of-eigenvalues"><span class="header-section-number">3.2.2</span> Key Properties of Eigenvalues</h3>
<p>The shortcuts above hint at a deeper connection. Here are the most important properties of eigenvalues for any <span class="math inline">\(n \times n\)</span> matrix <span class="math inline">\(A\)</span>.</p>
<ul>
<li><strong>Sum:</strong> The sum of the eigenvalues is equal to the trace of the matrix. <span class="math display">\[ \sum_{i=1}^{n} \lambda_i = \text{trace}(A) \]</span></li>
<li><strong>Product:</strong> The product of the eigenvalues is equal to the determinant of the matrix. <span class="math display">\[ \prod_{i=1}^{n} \lambda_i = \det(A) \]</span></li>
<li><strong>Singularity:</strong> A matrix is singular (not invertible) if and only if at least one of its eigenvalues is zero. (This follows directly from the product property).</li>
<li><strong>Powers:</strong> The eigenvalues of <span class="math inline">\(A^k\)</span> are <span class="math inline">\(\lambda_1^k, \lambda_2^k, \dots, \lambda_n^k\)</span>.</li>
<li><strong>Inverse:</strong> The eigenvalues of <span class="math inline">\(A^{-1}\)</span> are <span class="math inline">\(1/\lambda_1, 1/\lambda_2, \dots, 1/\lambda_n\)</span>.</li>
<li><strong>Transpose:</strong> A matrix and its transpose, <span class="math inline">\(A\)</span> and <span class="math inline">\(A^T\)</span>, have the same eigenvalues.</li>
<li><strong>Triangular Matrices:</strong> The eigenvalues of a triangular (or diagonal) matrix are simply the entries on its main diagonal.</li>
</ul>
<p>Let’s verify a few of these properties with code.</p>
<div id="verify-properties" class="cell" data-execution_count="2">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="co"># A sample 3x3 matrix</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> np.array([</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">2</span>, <span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>],</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">6</span>, <span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>],</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    [<span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">2</span>, <span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>])</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Get the eigenvalues using NumPy</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>eigenvalues <span class="op">=</span> np.linalg.eigvals(A)</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"The matrix A is:</span><span class="ch">\n</span><span class="sc">{</span>A<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Its eigenvalues are: </span><span class="sc">{</span>eigenvalues<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Verify the Sum property</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>sum_of_eigenvalues <span class="op">=</span> np.<span class="bu">sum</span>(eigenvalues)</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>trace_of_A <span class="op">=</span> np.trace(A)</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Sum of eigenvalues: </span><span class="sc">{</span>sum_of_eigenvalues<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Trace of A: </span><span class="sc">{</span>trace_of_A<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Are they close? </span><span class="sc">{</span>np<span class="sc">.</span>isclose(sum_of_eigenvalues, trace_of_A)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a><span class="co"># Verify the Product property</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>product_of_eigenvalues <span class="op">=</span> np.prod(eigenvalues)</span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>determinant_of_A <span class="op">=</span> np.linalg.det(A)</span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Product of eigenvalues: </span><span class="sc">{</span>product_of_eigenvalues<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Determinant of A: </span><span class="sc">{</span>determinant_of_A<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Are they close? </span><span class="sc">{</span>np<span class="sc">.</span>isclose(product_of_eigenvalues, determinant_of_A)<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>The matrix A is:
[[ 2  1 -1]
 [ 6 -1  0]
 [-1 -2 -1]]

Its eigenvalues are: [ 3.91899444+0.j         -1.95949722+1.23243177j -1.95949722-1.23243177j]

Sum of eigenvalues: 0.0000+0.0000j
Trace of A: 0
Are they close? True

Product of eigenvalues: 21.0000+0.0000j
Determinant of A: 21.0000
Are they close? True</code></pre>
</div>
</div>
</section>
<section id="example-finding-eigenvectors-by-hand" class="level3" data-number="3.2.3">
<h3 data-number="3.2.3" class="anchored" data-anchor-id="example-finding-eigenvectors-by-hand"><span class="header-section-number">3.2.3</span> Example: Finding Eigenvectors by Hand</h3>
<p>Now that we have the eigenvalues, how do we find the eigenvectors? We solve the system <span class="math inline">\((A - \lambda I)x = 0\)</span>. Let’s do this for our first example, <span class="math inline">\(A = \begin{bmatrix} 4 &amp; -2 \\ 1 &amp; 1 \end{bmatrix}\)</span>, where we found <span class="math inline">\(\lambda_1 = 3\)</span> and <span class="math inline">\(\lambda_2 = 2\)</span>.</p>
<p><strong>Case 1: Find eigenvector for <span class="math inline">\(\lambda_1 = 3\)</span>.</strong></p>
<p>We need to solve <span class="math inline">\((A - 3I)x = 0\)</span>. <span class="math display">\[ (A - 3I) = \begin{bmatrix} 4-3 &amp; -2 \\ 1 &amp; 1-3 \end{bmatrix} = \begin{bmatrix} 1 &amp; -2 \\ 1 &amp; -2 \end{bmatrix} \]</span> So the system is: <span class="math display">\[ \begin{bmatrix} 1 &amp; -2 \\ 1 &amp; -2 \end{bmatrix} \begin{bmatrix} x_1 \\ x_2 \end{bmatrix} = \begin{bmatrix} 0 \\ 0 \end{bmatrix} \]</span> Both rows give the same equation: <span class="math inline">\(x_1 - 2x_2 = 0\)</span>, or <span class="math inline">\(x_1 = 2x_2\)</span>. This system has a free variable! If we choose <span class="math inline">\(x_2 = 1\)</span>, then <span class="math inline">\(x_1 = 2\)</span>. So our eigenvector is a multiple of <span class="math inline">\(v_1 = \begin{bmatrix} 2 \\ 1 \end{bmatrix}\)</span>.</p>
<p><strong>Case 2: Find eigenvector for <span class="math inline">\(\lambda_2 = 2\)</span>.</strong></p>
<p>We need to solve <span class="math inline">\((A - 2I)x = 0\)</span>. <span class="math display">\[ (A - 2I) = \begin{bmatrix} 4-2 &amp; -2 \\ 1 &amp; 1-2 \end{bmatrix} = \begin{bmatrix} 2 &amp; -2 \\ 1 &amp; -1 \end{bmatrix} \]</span> The system is <span class="math inline">\(2x_1 - 2x_2 = 0\)</span>, or <span class="math inline">\(x_1 = x_2\)</span>. If we choose <span class="math inline">\(x_2=1\)</span>, then <span class="math inline">\(x_1=1\)</span>. So our eigenvector is a multiple of <span class="math inline">\(v_2 = \begin{bmatrix} 1 \\ 1 \end{bmatrix}\)</span>.</p>
<p>These match the results we get from our computer programs perfectly!</p>
</section>
</section>
<section id="the-geometry-of-eigenvectors" class="level2" data-number="3.3">
<h2 data-number="3.3" class="anchored" data-anchor-id="the-geometry-of-eigenvectors"><span class="header-section-number">3.3</span> The Geometry of Eigenvectors</h2>
<p>Let’s visualize what the matrix <span class="math inline">\(A\)</span> does to the plane. We will take a circle of vectors, apply the matrix <span class="math inline">\(A\)</span> to each one, and see where they land. The circle will be transformed into an ellipse.</p>
<p>The key thing to watch for is that the eigenvectors lie along the axes of this new ellipse. They are the only vectors that don’t get rotated off their original line.</p>
<div id="cell-fig-eigenvector-geometry" class="cell" data-execution_count="3">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Define the matrix A</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> np.array([</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">4</span>, <span class="op">-</span><span class="dv">2</span>],</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">1</span>,  <span class="dv">1</span>]</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>])</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Get eigenvalues and eigenvectors</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>eigvals, eigvecs <span class="op">=</span> np.linalg.eig(A)</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>v1 <span class="op">=</span> eigvecs[:, <span class="dv">0</span>]</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>v2 <span class="op">=</span> eigvecs[:, <span class="dv">1</span>]</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a unit circle</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>theta <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">2</span><span class="op">*</span>np.pi, <span class="dv">200</span>)</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>circle_vectors <span class="op">=</span> np.array([np.cos(theta), np.sin(theta)])</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Transform the circle into an ellipse</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>transformed_vectors <span class="op">=</span> A <span class="op">@</span> circle_vectors</span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a><span class="co"># --- Plot ---</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">6</span>, <span class="dv">6</span>))</span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a><span class="co"># Original circle (blue)</span></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>ax.plot(circle_vectors[<span class="dv">0</span>, :], circle_vectors[<span class="dv">1</span>, :], color<span class="op">=</span><span class="st">'blue'</span>, label<span class="op">=</span><span class="st">'Original Circle'</span>)</span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a><span class="co"># Transformed ellipse (green)</span></span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a>ax.plot(transformed_vectors[<span class="dv">0</span>, :], transformed_vectors[<span class="dv">1</span>, :], color<span class="op">=</span><span class="st">'green'</span>, label<span class="op">=</span><span class="st">'Transformed Ellipse'</span>)</span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a><span class="co"># Eigenvectors transformed (red dashed) — scaled by eigenvalues</span></span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a>ax.plot([<span class="dv">0</span>, eigvals[<span class="dv">0</span>] <span class="op">*</span> v1[<span class="dv">0</span>]], [<span class="dv">0</span>, eigvals[<span class="dv">0</span>] <span class="op">*</span> v1[<span class="dv">1</span>]], <span class="st">'r--'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="ss">f'Eigenvector λ=</span><span class="sc">{</span>eigvals[<span class="dv">0</span>]<span class="sc">:.2f}</span><span class="ss">'</span>)</span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true" tabindex="-1"></a>ax.plot([<span class="dv">0</span>, eigvals[<span class="dv">1</span>] <span class="op">*</span> v2[<span class="dv">0</span>]], [<span class="dv">0</span>, eigvals[<span class="dv">1</span>] <span class="op">*</span> v2[<span class="dv">1</span>]], <span class="st">'r--'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="ss">f'Eigenvector λ=</span><span class="sc">{</span>eigvals[<span class="dv">1</span>]<span class="sc">:.2f}</span><span class="ss">'</span>)</span>
<span id="cb5-34"><a href="#cb5-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-35"><a href="#cb5-35" aria-hidden="true" tabindex="-1"></a><span class="co"># Formatting</span></span>
<span id="cb5-36"><a href="#cb5-36" aria-hidden="true" tabindex="-1"></a>ax.set_aspect(<span class="st">'equal'</span>, adjustable<span class="op">=</span><span class="st">'box'</span>)</span>
<span id="cb5-37"><a href="#cb5-37" aria-hidden="true" tabindex="-1"></a>ax.set_xlim(<span class="op">-</span><span class="dv">5</span>, <span class="dv">5</span>)</span>
<span id="cb5-38"><a href="#cb5-38" aria-hidden="true" tabindex="-1"></a>ax.set_ylim(<span class="op">-</span><span class="dv">5</span>, <span class="dv">5</span>)</span>
<span id="cb5-39"><a href="#cb5-39" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">'X-axis'</span>)</span>
<span id="cb5-40"><a href="#cb5-40" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">'Y-axis'</span>)</span>
<span id="cb5-41"><a href="#cb5-41" aria-hidden="true" tabindex="-1"></a>ax.set_title(<span class="st">'Geometric Action of a Matrix'</span>)</span>
<span id="cb5-42"><a href="#cb5-42" aria-hidden="true" tabindex="-1"></a>ax.legend()</span>
<span id="cb5-43"><a href="#cb5-43" aria-hidden="true" tabindex="-1"></a>ax.grid(<span class="va">True</span>)</span>
<span id="cb5-44"><a href="#cb5-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-45"><a href="#cb5-45" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div id="fig-eigenvector-geometry" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-eigenvector-geometry-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="module2_files/figure-html/fig-eigenvector-geometry-output-1.png" width="510" height="523" class="figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-eigenvector-geometry-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3.1: The unit circle (blue) is transformed into an ellipse (green). The eigenvectors (red) only stretch, keeping their direction.
</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="tutorial-3--eigen-values-and-eigen-vectors-in-engineering-applications" class="level2" data-number="3.4">
<h2 data-number="3.4" class="anchored" data-anchor-id="tutorial-3--eigen-values-and-eigen-vectors-in-engineering-applications"><span class="header-section-number">3.4</span> Tutorial 3- Eigen values and Eigen vectors in Engineering Applications</h2>
<p><em>Solve each question using algebraic techniques:</em> form the characteristic polynomial, compute eigenvalues, find eigenvectors (mode shapes/principal directions/steady-state vectors), and verify algebraic and geometric multiplicities.</p>
<hr>
<section id="questions" class="level3" data-number="3.4.1">
<h3 data-number="3.4.1" class="anchored" data-anchor-id="questions"><span class="header-section-number">3.4.1</span> Questions</h3>
<ol type="1">
<li><strong>MEMS Resonator — Vibration Analysis</strong></li>
</ol>
<p>A MEMS resonator used in an oscillator circuit has stiffness matrix</p>
<p><span class="math display">\[K = \begin{bmatrix}6 &amp; -2 &amp; 0 \\ -2 &amp; 4 &amp; -2 \\ 0 &amp; -2 &amp; 6\end{bmatrix}.\]</span></p>
<ol type="a">
<li><p>Find the natural frequencies of vibration (eigenvalues of <span class="math inline">\(K\)</span>).</p></li>
<li><p>Determine the mode shapes of vibration (eigenvectors of <span class="math inline">\(K\)</span>).</p></li>
<li><p>Verify algebraic and geometric multiplicities of each eigenfrequency.</p></li>
<li><p>Explain the engineering meaning of each eigenvalue as a measure (e.g., squared natural frequency) and comment on stability.</p></li>
</ol>
<hr>
<ol start="2" type="1">
<li><strong>Wireless Channel Reliability</strong></li>
</ol>
<p>A discrete-time Markov model for a wireless channel has transition matrix</p>
<p><span class="math display">\[P = \begin{bmatrix}0.8 &amp; 0.2 \\ 0.3 &amp; 0.7\end{bmatrix}.\]</span></p>
<ol type="a">
<li><p>Compute the eigenvalues of <span class="math inline">\(P\)</span>.</p></li>
<li><p>Find the steady-state reliability vector (the eigenvector corresponding to <span class="math inline">\(\lambda=1\)</span>) and normalize it to a probability vector.</p></li>
<li><p>Verify algebraic and geometric multiplicities.</p></li>
<li><p>Interpret the dominant and subdominant eigenvalues with respect to long-term reliability and convergence speed.</p></li>
</ol>
<hr>
<ol start="3" type="1">
<li><strong>Image Compression via PCA</strong></li>
</ol>
<p>Covariance matrix of a 2-D feature (pixel intensities) is</p>
<p><span class="math display">\[C = \begin{bmatrix}5 &amp; 2 \\ 2 &amp; 2\end{bmatrix}.\]</span></p>
<ol type="a">
<li><p>Find the principal directions (eigenvectors) of <span class="math inline">\(C\)</span>.</p></li>
<li><p>Compute the variance explained by each direction (eigenvalues).</p></li>
<li><p>Verify algebraic and geometric multiplicities.</p></li>
<li><p>Compute the percentage of total variance captured by the largest eigenvalue (compression efficiency).</p></li>
</ol>
<hr>
<ol start="4" type="1">
<li><strong>Quantum 2-Level System (Hamiltonian)</strong></li>
</ol>
<p>The Hamiltonian of a two-level quantum system is</p>
<p><span class="math display">\[H = \begin{bmatrix}4 &amp; 1 \\ 1 &amp; 4\end{bmatrix}.\]</span></p>
<ol type="a">
<li><p>Find the energy levels (eigenvalues) of <span class="math inline">\(H\)</span>.</p></li>
<li><p>Determine the stationary states (normalized eigenvectors).</p></li>
<li><p>Verify algebraic and geometric multiplicities.</p></li>
<li><p>Express <span class="math inline">\(H\)</span> using spectral decomposition and state how eigenvalues control state evolution phases.</p></li>
</ol>
<hr>
<ol start="5" type="1">
<li><strong>Control System — State Matrix Modes</strong></li>
</ol>
<p>A linear time-invariant system has state matrix</p>
<p><span class="math display">\[A = \begin{bmatrix}0 &amp; 1 \\ -5 &amp; -4\end{bmatrix}.\]</span></p>
<ol type="a">
<li><p>Find the modes of system response (eigenvalues of <span class="math inline">\(A\)</span>).</p></li>
<li><p>Determine the response directions (eigenvectors) and indicate whether they are real or complex.</p></li>
<li><p>Verify algebraic and geometric multiplicities.</p></li>
<li><p>Interpret the real parts of eigenvalues as stability margins and the imaginary parts as oscillation frequency.</p></li>
</ol>
<hr>
</section>
<section id="solutions" class="level3" data-number="3.4.2">
<h3 data-number="3.4.2" class="anchored" data-anchor-id="solutions"><span class="header-section-number">3.4.2</span> Solutions</h3>
<blockquote class="blockquote">
<p><strong>1. MEMS Resonator — Vibration Modes and Stability</strong></p>
</blockquote>
<p><strong>(a) Characteristic polynomial and eigenvalues.</strong></p>
<p>Compute <span class="math inline">\(\det(K-\lambda I)=0\)</span>. The characteristic polynomial simplifies to</p>
<p><span class="math display">\[-\lambda^3 +16\lambda^2 -76\lambda +96 = 0,\]</span></p>
<p>whose real positive roots are</p>
<p><span class="math display">\[\lambda_1 = 2,\quad \lambda_2 = 6,\quad \lambda_3 = 8.\]</span></p>
<p><strong>(b) Mode shapes (eigenvectors).</strong></p>
<p>Solve <span class="math inline">\((K-\lambda I)\mathbf v=0\)</span> for each root:</p>
<ul>
<li>For <span class="math inline">\(\lambda_1=2\)</span>: <span class="math inline">\(\mathbf v_1 = [1,\,2,\,1]^T\)</span>.</li>
<li>For <span class="math inline">\(\lambda_2=6\)</span>: <span class="math inline">\(\mathbf v_2 = [-1,\,0,\,1]^T\)</span>.</li>
<li>For <span class="math inline">\(\lambda_3=8\)</span>: <span class="math inline">\(\mathbf v_3 = [1,\,-1,\,1]^T\)</span>.</li>
</ul>
<p>(Students may present normalized forms.)</p>
<blockquote class="blockquote">
<p><em>Python code</em></p>
</blockquote>
<div id="232ce99b" class="cell" data-execution_count="4">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Stiffness matrix</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>K <span class="op">=</span> np.array([[<span class="dv">6</span>, <span class="op">-</span><span class="dv">2</span>, <span class="dv">0</span>],</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>              [<span class="op">-</span><span class="dv">2</span>, <span class="dv">4</span>, <span class="op">-</span><span class="dv">2</span>],</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>              [<span class="dv">0</span>, <span class="op">-</span><span class="dv">2</span>, <span class="dv">6</span>]])</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Eigenvalues and eigenvectors</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>eigvals, eigvecs <span class="op">=</span> np.linalg.eig(K)</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Eigenvalues:"</span>, eigvals)</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Mode Shapes (eigenvectors):"</span>)</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(eigvecs)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Eigenvalues: [2. 6. 8.]
Mode Shapes (eigenvectors):
[[ 4.08248290e-01 -7.07106781e-01  5.77350269e-01]
 [ 8.16496581e-01  4.02240178e-16 -5.77350269e-01]
 [ 4.08248290e-01  7.07106781e-01  5.77350269e-01]]</code></pre>
</div>
</div>
<p><strong>(c) Multiplicities.</strong></p>
<p>Each eigenvalue appears once in the characteristic polynomial (algebraic multiplicity = 1) and has one independent eigenvector (geometric multiplicity = 1).</p>
<p><strong>(d) Engineering interpretation.</strong></p>
<p>Assuming mass normalization, eigenvalues correspond to squared natural angular frequencies <span class="math inline">\(\omega^2\)</span>. Therefore</p>
<p><span class="math display">\[\omega_1=\sqrt{2},\;\omega_2=\sqrt{6},\;\omega_3=\sqrt{8}.\]</span></p>
<p>All eigenvalues positive and simple imply distinct, stable oscillatory modes; no zero/negative eigenvalues appear, so no rigid-body mode or instability is present.</p>
<hr>
<blockquote class="blockquote">
<p><strong>2. Wireless Channel Reliability — Long-term Measure &amp; Convergence</strong></p>
</blockquote>
<p><strong>(a) Eigenvalues.</strong></p>
<p>Solve <span class="math inline">\(\det(P-\lambda I)=0\)</span> to get</p>
<p><span class="math display">\[\lambda_1 = 1,\qquad \lambda_2 = \tfrac{1}{2}.\]</span></p>
<p><strong>(b) Steady-state vector.</strong></p>
<p>Solve <span class="math inline">\((P-I)\mathbf v=0\)</span>. One eigenvector is <span class="math inline">\([1,1]^T\)</span>, normalized to</p>
<p><span class="math display">\[\pi = \begin{bmatrix}1/2\\\\[4pt]1/2\end{bmatrix}.\]</span></p>
<p><strong>(c) Multiplicities.</strong></p>
<p>Both eigenvalues are simple: algebraic multiplicity = 1 and geometric multiplicity = 1.</p>
<p><strong>(d) Engineering meaning.</strong></p>
<p><span class="math inline">\(\lambda_1=1\)</span> yields the steady-state distribution (long-term reliability). The subdominant eigenvalue <span class="math inline">\(\lambda_2=0.5\)</span> determines exponential convergence speed: transients decay as <span class="math inline">\((0.5)^t\)</span>.</p>
<blockquote class="blockquote">
<p><em>Python code</em></p>
</blockquote>
<div id="80879570" class="cell" data-execution_count="5">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> np.array([[<span class="fl">0.8</span>, <span class="fl">0.3</span>],</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>              [<span class="fl">0.2</span>, <span class="fl">0.7</span>]])</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>eigvals, eigvecs <span class="op">=</span> np.linalg.eig(A)</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Eigenvalues:"</span>, eigvals)</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Eigenvectors:"</span>)</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(eigvecs)</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Check stability</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>stable <span class="op">=</span> <span class="bu">all</span>(<span class="bu">abs</span>(eigvals) <span class="op">&lt;</span> <span class="dv">1</span>)</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"System stable?"</span>, stable)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Eigenvalues: [1.  0.5]
Eigenvectors:
[[ 0.83205029 -0.70710678]
 [ 0.5547002   0.70710678]]
System stable? False</code></pre>
</div>
</div>
<hr>
<blockquote class="blockquote">
<p><strong>3. PCA — Principal Directions and Variance Explained</strong></p>
</blockquote>
<p><strong>(a) Eigenvalues.</strong></p>
<p>Solve <span class="math inline">\(\det(C-\lambda I)=0\)</span> to obtain</p>
<p><span class="math display">\[\lambda_1 = 6,\qquad \lambda_2 = 1.\]</span></p>
<p><strong>(b) Eigenvectors (principal directions).</strong></p>
<ul>
<li>For <span class="math inline">\(\lambda_1=6\)</span>: <span class="math inline">\(\mathbf u_1=[2,\,1]^T\)</span> (principal direction).</li>
<li>For <span class="math inline">\(\lambda_2=1\)</span>: <span class="math inline">\(\mathbf u_2=[-1,\,2]^T\)</span>.</li>
</ul>
<p><strong>(c) Multiplicities.</strong></p>
<p>Distinct eigenvalues ⇒ algebraic multiplicities = geometric multiplicities = 1.</p>
<p><strong>(d) Compression efficiency.</strong></p>
<p>Total variance <span class="math inline">\(=6+1=7\)</span>. Fraction captured by first PC:</p>
<p><span class="math display">\[\frac{6}{7}\approx 85.71\%.\]</span></p>
<p>Projecting onto the first principal direction retains ~85.7% of variance.</p>
<blockquote class="blockquote">
<p><em>Python code</em></p>
</blockquote>
<div id="9805dbf2" class="cell" data-execution_count="6">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Covariance matrix from Question 3</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>C <span class="op">=</span> np.array([[<span class="fl">5.</span>, <span class="fl">2.</span>],</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>              [<span class="fl">2.</span>, <span class="fl">2.</span>]])</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="co"># eigendecomposition</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>eigvals, eigvecs <span class="op">=</span> np.linalg.eig(C)</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a><span class="co"># sort in descending order of eigenvalue</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>idx <span class="op">=</span> np.argsort(eigvals)[::<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>eigvals <span class="op">=</span> eigvals[idx]</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>eigvecs <span class="op">=</span> eigvecs[:, idx]</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a><span class="co"># normalize eigenvectors (columns) to unit length</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>eigvecs_norm <span class="op">=</span> eigvecs <span class="op">/</span> np.linalg.norm(eigvecs, axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Covariance matrix C:</span><span class="ch">\n</span><span class="st">"</span>, C)</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Eigenvalues (sorted):"</span>, eigvals)</span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Normalized eigenvectors (columns correspond to eigenvalues):</span><span class="ch">\n</span><span class="st">"</span>, eigvecs_norm)</span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a><span class="co"># Variance explained</span></span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>total_var <span class="op">=</span> eigvals.<span class="bu">sum</span>()</span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>fractions <span class="op">=</span> eigvals <span class="op">/</span> total_var</span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Total variance: </span><span class="sc">{:.6f}</span><span class="st">"</span>.<span class="bu">format</span>(total_var))</span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i,(lam, frac) <span class="kw">in</span> <span class="bu">enumerate</span>(<span class="bu">zip</span>(eigvals, fractions), start<span class="op">=</span><span class="dv">1</span>):</span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"PC</span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">: eigenvalue = </span><span class="sc">{</span>lam<span class="sc">:.6f}</span><span class="ss">  -&gt; variance = </span><span class="sc">{</span>frac<span class="op">*</span><span class="dv">100</span><span class="sc">:.4f}</span><span class="ss">%"</span>)</span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true" tabindex="-1"></a><span class="co"># Algebraic multiplicity (cluster equal eigenvalues within tol)</span></span>
<span id="cb10-30"><a href="#cb10-30" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> algebraic_multiplicities(vals, tol<span class="op">=</span><span class="fl">1e-8</span>):</span>
<span id="cb10-31"><a href="#cb10-31" aria-hidden="true" tabindex="-1"></a>    vals <span class="op">=</span> <span class="bu">list</span>(vals)</span>
<span id="cb10-32"><a href="#cb10-32" aria-hidden="true" tabindex="-1"></a>    used <span class="op">=</span> [<span class="va">False</span>]<span class="op">*</span><span class="bu">len</span>(vals)</span>
<span id="cb10-33"><a href="#cb10-33" aria-hidden="true" tabindex="-1"></a>    clusters <span class="op">=</span> []</span>
<span id="cb10-34"><a href="#cb10-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i,v <span class="kw">in</span> <span class="bu">enumerate</span>(vals):</span>
<span id="cb10-35"><a href="#cb10-35" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> used[i]:</span>
<span id="cb10-36"><a href="#cb10-36" aria-hidden="true" tabindex="-1"></a>            <span class="cf">continue</span></span>
<span id="cb10-37"><a href="#cb10-37" aria-hidden="true" tabindex="-1"></a>        cnt <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb10-38"><a href="#cb10-38" aria-hidden="true" tabindex="-1"></a>        used[i] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb10-39"><a href="#cb10-39" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i<span class="op">+</span><span class="dv">1</span>, <span class="bu">len</span>(vals)):</span>
<span id="cb10-40"><a href="#cb10-40" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (<span class="kw">not</span> used[j]) <span class="kw">and</span> (<span class="bu">abs</span>(vals[j] <span class="op">-</span> v) <span class="op">&lt;</span> tol):</span>
<span id="cb10-41"><a href="#cb10-41" aria-hidden="true" tabindex="-1"></a>                cnt <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb10-42"><a href="#cb10-42" aria-hidden="true" tabindex="-1"></a>                used[j] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb10-43"><a href="#cb10-43" aria-hidden="true" tabindex="-1"></a>        clusters.append((v, cnt))</span>
<span id="cb10-44"><a href="#cb10-44" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> clusters</span>
<span id="cb10-45"><a href="#cb10-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-46"><a href="#cb10-46" aria-hidden="true" tabindex="-1"></a><span class="co"># Geometric multiplicity = dimension of nullspace of (C - lambda I) = n - rank(C - lambda I)</span></span>
<span id="cb10-47"><a href="#cb10-47" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> geometric_multiplicity(A, lam, tol<span class="op">=</span><span class="fl">1e-10</span>):</span>
<span id="cb10-48"><a href="#cb10-48" aria-hidden="true" tabindex="-1"></a>    M <span class="op">=</span> A <span class="op">-</span> lam <span class="op">*</span> np.eye(A.shape[<span class="dv">0</span>])</span>
<span id="cb10-49"><a href="#cb10-49" aria-hidden="true" tabindex="-1"></a>    rank <span class="op">=</span> np.linalg.matrix_rank(M, tol<span class="op">=</span>tol)</span>
<span id="cb10-50"><a href="#cb10-50" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> A.shape[<span class="dv">0</span>] <span class="op">-</span> rank</span>
<span id="cb10-51"><a href="#cb10-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-52"><a href="#cb10-52" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Algebraic multiplicities (value, count):"</span>, algebraic_multiplicities(eigvals))</span>
<span id="cb10-53"><a href="#cb10-53" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> lam <span class="kw">in</span> np.unique(np.<span class="bu">round</span>(eigvals, <span class="dv">12</span>)):</span>
<span id="cb10-54"><a href="#cb10-54" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Geometric multiplicity of λ=</span><span class="sc">{</span>lam<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>geometric_multiplicity(C, lam)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb10-55"><a href="#cb10-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-56"><a href="#cb10-56" aria-hidden="true" tabindex="-1"></a><span class="co"># Helper: integer-proportional presentation of eigenvectors (useful for handouts)</span></span>
<span id="cb10-57"><a href="#cb10-57" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> integer_representation(v, tol<span class="op">=</span><span class="fl">1e-8</span>):</span>
<span id="cb10-58"><a href="#cb10-58" aria-hidden="true" tabindex="-1"></a>    <span class="co"># scale vector so the smallest non-zero absolute entry becomes 1 (or -1), then round</span></span>
<span id="cb10-59"><a href="#cb10-59" aria-hidden="true" tabindex="-1"></a>    nonzero <span class="op">=</span> np.<span class="bu">abs</span>(v) <span class="op">&gt;</span> tol</span>
<span id="cb10-60"><a href="#cb10-60" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> nonzero.<span class="bu">any</span>():</span>
<span id="cb10-61"><a href="#cb10-61" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> np.zeros_like(v, dtype<span class="op">=</span><span class="bu">int</span>)</span>
<span id="cb10-62"><a href="#cb10-62" aria-hidden="true" tabindex="-1"></a>    scale <span class="op">=</span> np.<span class="bu">min</span>(np.<span class="bu">abs</span>(v[nonzero]))</span>
<span id="cb10-63"><a href="#cb10-63" aria-hidden="true" tabindex="-1"></a>    v_scaled <span class="op">=</span> v <span class="op">/</span> scale</span>
<span id="cb10-64"><a href="#cb10-64" aria-hidden="true" tabindex="-1"></a>    v_int <span class="op">=</span> np.<span class="bu">round</span>(v_scaled).astype(<span class="bu">int</span>)</span>
<span id="cb10-65"><a href="#cb10-65" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> v_int</span>
<span id="cb10-66"><a href="#cb10-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-67"><a href="#cb10-67" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Integer-proportional eigenvectors (for presentation):"</span>)</span>
<span id="cb10-68"><a href="#cb10-68" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(eigvecs_norm.shape[<span class="dv">1</span>]):</span>
<span id="cb10-69"><a href="#cb10-69" aria-hidden="true" tabindex="-1"></a>    v <span class="op">=</span> eigvecs_norm[:, i]</span>
<span id="cb10-70"><a href="#cb10-70" aria-hidden="true" tabindex="-1"></a>    <span class="co"># fix sign convention for presentation: make first nonzero entry positive</span></span>
<span id="cb10-71"><a href="#cb10-71" aria-hidden="true" tabindex="-1"></a>    first_nonzero <span class="op">=</span> np.where(np.<span class="bu">abs</span>(v) <span class="op">&gt;</span> <span class="fl">1e-8</span>)[<span class="dv">0</span>][<span class="dv">0</span>]</span>
<span id="cb10-72"><a href="#cb10-72" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> v[first_nonzero] <span class="op">&lt;</span> <span class="dv">0</span>:</span>
<span id="cb10-73"><a href="#cb10-73" aria-hidden="true" tabindex="-1"></a>        v <span class="op">=</span> <span class="op">-</span>v</span>
<span id="cb10-74"><a href="#cb10-74" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"λ = </span><span class="sc">{</span>eigvals[i]<span class="sc">:.6f}</span><span class="ss"> : approx vector -&gt;"</span>, integer_representation(v))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Covariance matrix C:
 [[5. 2.]
 [2. 2.]]

Eigenvalues (sorted): [6. 1.]
Normalized eigenvectors (columns correspond to eigenvalues):
 [[ 0.89442719 -0.4472136 ]
 [ 0.4472136   0.89442719]]

Total variance: 7.000000
PC1: eigenvalue = 6.000000  -&gt; variance = 85.7143%
PC2: eigenvalue = 1.000000  -&gt; variance = 14.2857%

Algebraic multiplicities (value, count): [(6.0, 1), (1.0, 1)]
Geometric multiplicity of λ=1.0: 1
Geometric multiplicity of λ=6.0: 1

Integer-proportional eigenvectors (for presentation):
λ = 6.000000 : approx vector -&gt; [2 1]
λ = 1.000000 : approx vector -&gt; [ 1 -2]</code></pre>
</div>
</div>
<hr>
<blockquote class="blockquote">
<p><strong>4. Quantum 2-Level System — Energy Levels &amp; Stationary States</strong></p>
</blockquote>
<p><strong>(a) Eigenvalues (energy levels).</strong></p>
<p>Solve <span class="math inline">\(\det(H-\lambda I)=0\)</span>; roots are</p>
<p><span class="math display">\[\lambda_1 = 3,\quad \lambda_2 = 5.\]</span></p>
<p><strong>(b) Normalized stationary states.</strong></p>
<ul>
<li>For <span class="math inline">\(\lambda_1=3\)</span>: <span class="math inline">\(\mathbf p_1 = \tfrac{1}{\sqrt{2}}[-1,\,1]^T\)</span>.</li>
<li>For <span class="math inline">\(\lambda_2=5\)</span>: <span class="math inline">\(\mathbf p_2 = \tfrac{1}{\sqrt{2}}[1,\,1]^T\)</span>.</li>
</ul>
<p><strong>(c) Multiplicities.</strong></p>
<p>Both simple (algebraic = geometric = 1).</p>
<p><strong>(d) Spectral decomposition.</strong></p>
<p><span class="math display">\[H = 3\,\mathbf p_1\mathbf p_1^T + 5\,\mathbf p_2\mathbf p_2^T.\]</span></p>
<p>Time evolution <span class="math inline">\(e^{-iHt}\)</span> applies phases <span class="math inline">\(e^{-i\lambda t}\)</span> to each stationary state.</p>
<blockquote class="blockquote">
<p><em>Python code</em></p>
</blockquote>
<div id="4e1055f7" class="cell" data-execution_count="7">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.linalg <span class="im">import</span> expm</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>H <span class="op">=</span> np.array([[<span class="dv">4</span>, <span class="dv">1</span>],</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>              [<span class="dv">1</span>, <span class="dv">4</span>]])</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>eigvals, eigvecs <span class="op">=</span> np.linalg.eig(H)</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Eigenvalues (energy levels):"</span>, eigvals)</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Eigenvectors (stationary states):</span><span class="ch">\n</span><span class="st">"</span>, eigvecs)</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Verify spectral decomposition</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>H_recon <span class="op">=</span> eigvecs <span class="op">@</span> np.diag(eigvals) <span class="op">@</span> np.linalg.inv(eigvecs)</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Reconstructed H:</span><span class="ch">\n</span><span class="st">"</span>, np.<span class="bu">round</span>(H_recon, <span class="dv">5</span>))</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Time evolution operator at t=1, ħ=1</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> <span class="fl">1.0</span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>U <span class="op">=</span> expm(<span class="op">-</span><span class="ot">1j</span> <span class="op">*</span> H <span class="op">*</span> t)</span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Time evolution operator U(t=1):</span><span class="ch">\n</span><span class="st">"</span>, np.<span class="bu">round</span>(U, <span class="dv">4</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Eigenvalues (energy levels): [5. 3.]
Eigenvectors (stationary states):
 [[ 0.70710678 -0.70710678]
 [ 0.70710678  0.70710678]]
Reconstructed H:
 [[4. 1.]
 [1. 4.]]
Time evolution operator U(t=1):
 [[-0.3532+0.4089j  0.6368+0.55j  ]
 [ 0.6368+0.55j   -0.3532+0.4089j]]</code></pre>
</div>
</div>
<hr>
<blockquote class="blockquote">
<ol start="5" type="1">
<li><strong>Control System — Modes &amp; Stability Margin</strong></li>
</ol>
</blockquote>
<p><strong>(a) Eigenvalues (modes).</strong></p>
<p>Characteristic equation <span class="math inline">\(\lambda^2 + 4\lambda + 5 = 0\)</span> gives</p>
<p><span class="math display">\[\lambda_{1,2} = -2 \pm i.\]</span></p>
<p><strong>(b) Eigenvectors.</strong></p>
<p>Corresponding complex eigenvectors can be computed; one representative for <span class="math inline">\(\lambda=-2+i\)</span> is</p>
<p><span class="math display">\[\mathbf v = \begin{bmatrix}-\tfrac{2}{5}+\tfrac{i}{5}\\\\[4pt] 1 \end{bmatrix}.\]</span></p>
<p>Real sinusoidal modes can be constructed from the complex eigenpairs.</p>
<p><strong>(c) Multiplicities.</strong></p>
<p>Distinct complex conjugate eigenvalues → algebraic multiplicity = geometric multiplicity = 1 for each.</p>
<p><strong>(d) Interpretation.</strong></p>
<p>Real part <span class="math inline">\(-2\)</span> indicates exponential decay (stable). Imaginary part <span class="math inline">\(\pm1\)</span> indicates oscillation frequency 1 rad/s. Decay envelope ~ <span class="math inline">\(e^{-2t}\)</span>.</p>
<blockquote class="blockquote">
<p><em>Python code</em></p>
</blockquote>
<div id="854a9ae0" class="cell" data-execution_count="8">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Control system (2x2) analysis: A = [[0,1],[-5,-4]]</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.linalg <span class="im">import</span> expm</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> np.array([[<span class="fl">0.</span>, <span class="fl">1.</span>],</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>              [<span class="op">-</span><span class="fl">5.</span>, <span class="op">-</span><span class="fl">4.</span>]])</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Eigen-decomposition</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>eigvals, eigvecs <span class="op">=</span> np.linalg.eig(A)   <span class="co"># eigvecs columns correspond to eigvals</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"A =</span><span class="ch">\n</span><span class="st">"</span>, A)</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Eigenvalues:"</span>)</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, lam <span class="kw">in</span> <span class="bu">enumerate</span>(eigvals, start<span class="op">=</span><span class="dv">1</span>):</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  λ</span><span class="sc">{</span>i<span class="sc">}</span><span class="ss"> = </span><span class="sc">{</span>lam<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Eigenvectors (columns):</span><span class="ch">\n</span><span class="st">"</span>, eigvecs)</span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Real and imaginary parts</span></span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Real parts of eigenvalues:"</span>, np.real(eigvals))</span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Imag parts of eigenvalues:"</span>, np.imag(eigvals))</span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a><span class="co"># Stability check: asymptotically stable if all real parts &lt; 0</span></span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true" tabindex="-1"></a>is_stable <span class="op">=</span> np.<span class="bu">all</span>(np.real(eigvals) <span class="op">&lt;</span> <span class="dv">0</span>)</span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Asymptotically stable?"</span>, is_stable)</span>
<span id="cb14-25"><a href="#cb14-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-26"><a href="#cb14-26" aria-hidden="true" tabindex="-1"></a><span class="co"># Algebraic multiplicities (count equal eigenvalues within tolerance)</span></span>
<span id="cb14-27"><a href="#cb14-27" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> algebraic_multiplicities(vals, tol<span class="op">=</span><span class="fl">1e-8</span>):</span>
<span id="cb14-28"><a href="#cb14-28" aria-hidden="true" tabindex="-1"></a>    vals_r <span class="op">=</span> np.<span class="bu">round</span>(vals.real, <span class="dv">8</span>) <span class="op">+</span> <span class="ot">1j</span><span class="op">*</span>np.<span class="bu">round</span>(vals.imag, <span class="dv">8</span>)</span>
<span id="cb14-29"><a href="#cb14-29" aria-hidden="true" tabindex="-1"></a>    unique, counts <span class="op">=</span> np.unique(vals_r, return_counts<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb14-30"><a href="#cb14-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">list</span>(<span class="bu">zip</span>(unique, counts))</span>
<span id="cb14-31"><a href="#cb14-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-32"><a href="#cb14-32" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Algebraic multiplicities:"</span>, algebraic_multiplicities(eigvals))</span>
<span id="cb14-33"><a href="#cb14-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-34"><a href="#cb14-34" aria-hidden="true" tabindex="-1"></a><span class="co"># Geometric multiplicity: n - rank(A - λI)</span></span>
<span id="cb14-35"><a href="#cb14-35" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> geometric_multiplicity(A, lam, tol<span class="op">=</span><span class="fl">1e-10</span>):</span>
<span id="cb14-36"><a href="#cb14-36" aria-hidden="true" tabindex="-1"></a>    M <span class="op">=</span> A <span class="op">-</span> lam <span class="op">*</span> np.eye(A.shape[<span class="dv">0</span>])</span>
<span id="cb14-37"><a href="#cb14-37" aria-hidden="true" tabindex="-1"></a>    rank <span class="op">=</span> np.linalg.matrix_rank(M, tol<span class="op">=</span>tol)</span>
<span id="cb14-38"><a href="#cb14-38" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> A.shape[<span class="dv">0</span>] <span class="op">-</span> rank</span>
<span id="cb14-39"><a href="#cb14-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-40"><a href="#cb14-40" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> lam <span class="kw">in</span> eigvals:</span>
<span id="cb14-41"><a href="#cb14-41" aria-hidden="true" tabindex="-1"></a>    gm <span class="op">=</span> geometric_multiplicity(A, lam)</span>
<span id="cb14-42"><a href="#cb14-42" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Geometric multiplicity of λ=</span><span class="sc">{</span>lam<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>gm<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb14-43"><a href="#cb14-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-44"><a href="#cb14-44" aria-hidden="true" tabindex="-1"></a><span class="co"># Check diagonalizability (geometric multiplicities == algebraic)</span></span>
<span id="cb14-45"><a href="#cb14-45" aria-hidden="true" tabindex="-1"></a><span class="co"># For small matrices we can check if eigvecs are linearly independent:</span></span>
<span id="cb14-46"><a href="#cb14-46" aria-hidden="true" tabindex="-1"></a>rank_eigvecs <span class="op">=</span> np.linalg.matrix_rank(eigvecs)</span>
<span id="cb14-47"><a href="#cb14-47" aria-hidden="true" tabindex="-1"></a>diag_ok <span class="op">=</span> (rank_eigvecs <span class="op">==</span> A.shape[<span class="dv">0</span>])</span>
<span id="cb14-48"><a href="#cb14-48" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Eigenvector matrix rank:"</span>, rank_eigvecs)</span>
<span id="cb14-49"><a href="#cb14-49" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Matrix diagonalizable over C?"</span>, diag_ok)</span>
<span id="cb14-50"><a href="#cb14-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-51"><a href="#cb14-51" aria-hidden="true" tabindex="-1"></a><span class="co"># Spectral reconstruction: A_recon = V * diag(lambda) * V^{-1}</span></span>
<span id="cb14-52"><a href="#cb14-52" aria-hidden="true" tabindex="-1"></a>A_recon <span class="op">=</span> eigvecs <span class="op">@</span> np.diag(eigvals) <span class="op">@</span> np.linalg.inv(eigvecs)</span>
<span id="cb14-53"><a href="#cb14-53" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Spectral reconstruction (A_recon):</span><span class="ch">\n</span><span class="st">"</span>, np.<span class="bu">round</span>(A_recon, <span class="dv">10</span>))</span>
<span id="cb14-54"><a href="#cb14-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-55"><a href="#cb14-55" aria-hidden="true" tabindex="-1"></a><span class="co"># If eigenvalues are complex conjugates, form real modal (real-valued 2x2 block) representation</span></span>
<span id="cb14-56"><a href="#cb14-56" aria-hidden="true" tabindex="-1"></a><span class="co"># and compute the real state transition e^{At} via expm</span></span>
<span id="cb14-57"><a href="#cb14-57" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> <span class="fl">0.5</span>  <span class="co"># example time</span></span>
<span id="cb14-58"><a href="#cb14-58" aria-hidden="true" tabindex="-1"></a>Phi <span class="op">=</span> expm(A <span class="op">*</span> t)</span>
<span id="cb14-59"><a href="#cb14-59" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">State-transition matrix e^</span><span class="ch">{{</span><span class="ss">A t</span><span class="ch">}}</span><span class="ss"> for t=</span><span class="sc">{</span>t<span class="sc">}</span><span class="ss">:</span><span class="ch">\n</span><span class="ss">"</span>, np.<span class="bu">round</span>(Phi, <span class="dv">6</span>))</span>
<span id="cb14-60"><a href="#cb14-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-61"><a href="#cb14-61" aria-hidden="true" tabindex="-1"></a><span class="co"># Provide a short interpretation printout</span></span>
<span id="cb14-62"><a href="#cb14-62" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Interpretation:"</span>)</span>
<span id="cb14-63"><a href="#cb14-63" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" - Eigenvalues provide modes: real part =&gt; decay rate, imag part =&gt; oscillation frequency."</span>)</span>
<span id="cb14-64"><a href="#cb14-64" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" - Here, eigenvalues = -2 ± 1j  =&gt; decaying oscillation with decay rate 2 and angular freq 1."</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>A =
 [[ 0.  1.]
 [-5. -4.]]

Eigenvalues:
  λ1 = (-2.0000000000000004+1.0000000000000004j)
  λ2 = (-2.0000000000000004-1.0000000000000004j)

Eigenvectors (columns):
 [[-0.36514837-0.18257419j -0.36514837+0.18257419j]
 [ 0.91287093+0.j          0.91287093-0.j        ]]

Real parts of eigenvalues: [-2. -2.]
Imag parts of eigenvalues: [ 1. -1.]

Asymptotically stable? True

Algebraic multiplicities: [((-2-1j), 1), ((-2+1j), 1)]
Geometric multiplicity of λ=(-2.0000000000000004+1.0000000000000004j): 1
Geometric multiplicity of λ=(-2.0000000000000004-1.0000000000000004j): 1

Eigenvector matrix rank: 2
Matrix diagonalizable over C? True

Spectral reconstruction (A_recon):
 [[-0.+0.j  1.-0.j]
 [-5.-0.j -4.-0.j]]

State-transition matrix e^{A t} for t=0.5:
 [[ 0.675586  0.176371]
 [-0.881854 -0.029897]]

Interpretation:
 - Eigenvalues provide modes: real part =&gt; decay rate, imag part =&gt; oscillation frequency.
 - Here, eigenvalues = -2 ± 1j  =&gt; decaying oscillation with decay rate 2 and angular freq 1.</code></pre>
</div>
</div>
<hr>
<blockquote class="blockquote">
<p><strong>Notes for instructors</strong></p>
</blockquote>
<ul>
<li>The answers above use convenient integer eigenvectors; students should be awarded full credit for any nonzero scalar multiple or normalized versions.</li>
<li>Encourage explicit algebraic steps: expansion of determinants, solving the linear systems for eigenvectors, and normalization when required.</li>
</ul>
<hr>
</section>
</section>
<section id="diagonalization-of-a-matrix" class="level2" data-number="3.5">
<h2 data-number="3.5" class="anchored" data-anchor-id="diagonalization-of-a-matrix"><span class="header-section-number">3.5</span> Diagonalization of a Matrix</h2>
<p>This brings us to one of the most powerful ideas in linear algebra: <strong>diagonalization</strong>. The goal is to write a matrix <span class="math inline">\(A\)</span> as a product of three simpler matrices.</p>
<blockquote class="blockquote">
<p><strong>The Diagonalization Formula</strong> <span class="math display">\[ A = S \Lambda S^{-1} \]</span> Where: * <span class="math inline">\(S\)</span> is the matrix whose columns are the eigenvectors of <span class="math inline">\(A\)</span>. * <span class="math inline">\(\Lambda\)</span> (Lambda) is the diagonal matrix with the eigenvalues on its diagonal.</p>
</blockquote>
<p>A matrix can be diagonalized if and only if it has a full set of linearly independent eigenvectors.</p>
<p>Why is this so useful? Consider computing <span class="math inline">\(A^{100}\)</span>. This would be a nightmare. But if <span class="math inline">\(A\)</span> is diagonalized: <span class="math display">\[ A^2 = (S \Lambda S^{-1})(S \Lambda S^{-1}) = S \Lambda (S^{-1}S) \Lambda S^{-1} = S \Lambda^2 S^{-1} \]</span> In general: <span class="math display">\[ A^k = S \Lambda^k S^{-1} \]</span> Computing <span class="math inline">\(\Lambda^k\)</span> is trivial: you just raise the diagonal entries to the <span class="math inline">\(k\)</span>-th power!</p>
<section id="example-verifying-diagonalization" class="level3" data-number="3.5.1">
<h3 data-number="3.5.1" class="anchored" data-anchor-id="example-verifying-diagonalization"><span class="header-section-number">3.5.1</span> Example: Verifying Diagonalization</h3>
<p>Let’s verify <span class="math inline">\(A = S \Lambda S^{-1}\)</span> and compute <span class="math inline">\(A^3\)</span> for our matrix.</p>
<div id="verify-diagonalization" class="cell" data-execution_count="9">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Our matrix A</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> np.array([</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">4</span>, <span class="op">-</span><span class="dv">2</span>],</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">1</span>,  <span class="dv">1</span>]</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>], dtype<span class="op">=</span><span class="bu">float</span>)  <span class="co"># ensure float for safety in inverse</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a><span class="co"># NumPy's eig function gives both eigenvalues and eigenvectors</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>eigenvalues, eigenvectors <span class="op">=</span> np.linalg.eig(A)</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a><span class="co"># S is the matrix of eigenvectors</span></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>S <span class="op">=</span> eigenvectors</span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Λ is the diagonal matrix of eigenvalues</span></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>Lambda <span class="op">=</span> np.diag(eigenvalues)</span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Matrix S (Eigenvectors):"</span>)</span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(S)</span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Matrix Λ (Eigenvalues):"</span>)</span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(Lambda)</span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate S-inverse</span></span>
<span id="cb16-23"><a href="#cb16-23" aria-hidden="true" tabindex="-1"></a>S_inv <span class="op">=</span> np.linalg.inv(S)</span>
<span id="cb16-24"><a href="#cb16-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-25"><a href="#cb16-25" aria-hidden="true" tabindex="-1"></a><span class="co"># Verify A = SΛS⁻¹</span></span>
<span id="cb16-26"><a href="#cb16-26" aria-hidden="true" tabindex="-1"></a>A_reconstructed <span class="op">=</span> S <span class="op">@</span> Lambda <span class="op">@</span> S_inv</span>
<span id="cb16-27"><a href="#cb16-27" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Reconstructed A = SΛS⁻¹:"</span>)</span>
<span id="cb16-28"><a href="#cb16-28" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(A_reconstructed)</span>
<span id="cb16-29"><a href="#cb16-29" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Is it close to the original A?"</span>, np.allclose(A, A_reconstructed))</span>
<span id="cb16-30"><a href="#cb16-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-31"><a href="#cb16-31" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute A³ directly</span></span>
<span id="cb16-32"><a href="#cb16-32" aria-hidden="true" tabindex="-1"></a>A_cubed_direct <span class="op">=</span> np.linalg.matrix_power(A, <span class="dv">3</span>)</span>
<span id="cb16-33"><a href="#cb16-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-34"><a href="#cb16-34" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute A³ using diagonalization</span></span>
<span id="cb16-35"><a href="#cb16-35" aria-hidden="true" tabindex="-1"></a>Lambda_cubed <span class="op">=</span> np.diag(eigenvalues<span class="op">**</span><span class="dv">3</span>)</span>
<span id="cb16-36"><a href="#cb16-36" aria-hidden="true" tabindex="-1"></a>A_cubed_diagonal <span class="op">=</span> S <span class="op">@</span> Lambda_cubed <span class="op">@</span> S_inv</span>
<span id="cb16-37"><a href="#cb16-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-38"><a href="#cb16-38" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">--- Computing A³ ---"</span>)</span>
<span id="cb16-39"><a href="#cb16-39" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Direct computation (A³):"</span>)</span>
<span id="cb16-40"><a href="#cb16-40" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(A_cubed_direct)</span>
<span id="cb16-41"><a href="#cb16-41" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Using diagonalization (SΛ³S⁻¹):"</span>)</span>
<span id="cb16-42"><a href="#cb16-42" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(A_cubed_diagonal)</span>
<span id="cb16-43"><a href="#cb16-43" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Are the results close?"</span>, np.allclose(A_cubed_direct, A_cubed_diagonal))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Matrix S (Eigenvectors):
[[0.89442719 0.70710678]
 [0.4472136  0.70710678]]

Matrix Λ (Eigenvalues):
[[3. 0.]
 [0. 2.]]

Reconstructed A = SΛS⁻¹:
[[ 4. -2.]
 [ 1.  1.]]

Is it close to the original A? True

--- Computing A³ ---
Direct computation (A³):
[[ 46. -38.]
 [ 19. -11.]]

Using diagonalization (SΛ³S⁻¹):
[[ 46. -38.]
 [ 19. -11.]]

Are the results close? True</code></pre>
</div>
</div>
</section>
</section>
<section id="symmetric-and-orthogonal-matrices" class="level2" data-number="3.6">
<h2 data-number="3.6" class="anchored" data-anchor-id="symmetric-and-orthogonal-matrices"><span class="header-section-number">3.6</span> Symmetric and Orthogonal Matrices</h2>
<p>Things get even nicer for a very special class of matrices: <strong>symmetric matrices</strong>, where <span class="math inline">\(A = A^T\)</span>.</p>
<p>Symmetric matrices have two incredible properties: 1. All their eigenvalues are real numbers. 2. Their eigenvectors can be chosen to be <strong>orthogonal</strong> (perpendicular to each other).</p>
<p>If we normalize the eigenvectors (make them unit length), they form an <strong>orthonormal set</strong>. The matrix <span class="math inline">\(Q\)</span> whose columns are these orthonormal eigenvectors is an <strong>orthogonal matrix</strong>.</p>
<p>Orthogonal matrices are wonderful because their inverse is simply their transpose: <span class="math inline">\(Q^{-1} = Q^T\)</span>.</p>
<p>This leads to the <strong>Spectral Theorem</strong>, which says that any symmetric matrix can be diagonalized as: <span class="math display">\[ A = Q \Lambda Q^T \]</span></p>
</section>
<section id="application-quadratic-forms" class="level2" data-number="3.7">
<h2 data-number="3.7" class="anchored" data-anchor-id="application-quadratic-forms"><span class="header-section-number">3.7</span> Application: Quadratic Forms</h2>
<p>What are these ideas good for? One classic application is understanding the geometry of <strong>quadratic forms</strong>. A quadratic form is a polynomial where every term has degree two. For example: <span class="math display">\[ f(x, y) = 2x^2 + 6xy + 2y^2 \]</span> This equation describes a shape on the plane. But what shape? The <span class="math inline">\(6xy\)</span> “cross-product” term makes it hard to see because it corresponds to a rotated shape. Our goal is to eliminate this term.</p>
<p>We can write any quadratic form using a symmetric matrix: <span class="math display">\[ f(x, y) = \begin{bmatrix} x &amp; y \end{bmatrix} \begin{bmatrix} 2 &amp; 3 \\ 3 &amp; 2 \end{bmatrix} \begin{bmatrix} x \\ y \end{bmatrix} = x^T A x \]</span></p>
<p>The eigenvectors of <span class="math inline">\(A\)</span> point along the principal axes of the shape, and the eigenvalues tell us the scaling in those directions. By changing to a coordinate system aligned with the eigenvectors, we can describe the shape without a cross-term.</p>
<p>Let’s find the axes of the ellipse given by <span class="math inline">\(2x^2 + 6xy + 2y^2 = 1\)</span>.</p>
<div id="cell-fig-quadratic-form" class="cell" data-execution_count="10">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Symmetric matrix for the quadratic form</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> np.array([</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">3</span>, <span class="dv">1</span>],</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">1</span>, <span class="dv">2</span>]</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>])</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Eigen-decomposition gives the axes and scaling</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>eigvals, eigvecs <span class="op">=</span> np.linalg.eig(A)</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>v1 <span class="op">=</span> eigvecs[:, <span class="dv">0</span>]</span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>v2 <span class="op">=</span> eigvecs[:, <span class="dv">1</span>]</span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate grid data</span></span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.linspace(<span class="op">-</span><span class="fl">1.5</span>, <span class="fl">1.5</span>, <span class="dv">400</span>)</span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> np.linspace(<span class="op">-</span><span class="fl">1.5</span>, <span class="fl">1.5</span>, <span class="dv">400</span>)</span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a>X, Y <span class="op">=</span> np.meshgrid(x, y)</span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a><span class="co"># Quadratic form value: F(x, y) = [x y] A [x; y]</span></span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a>F <span class="op">=</span> A[<span class="dv">0</span>, <span class="dv">0</span>] <span class="op">*</span> X<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> <span class="dv">2</span> <span class="op">*</span> A[<span class="dv">0</span>, <span class="dv">1</span>] <span class="op">*</span> X <span class="op">*</span> Y <span class="op">+</span> A[<span class="dv">1</span>, <span class="dv">1</span>] <span class="op">*</span> Y<span class="op">**</span><span class="dv">2</span></span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true" tabindex="-1"></a><span class="co"># Plotting</span></span>
<span id="cb18-24"><a href="#cb18-24" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">7</span>, <span class="dv">7</span>))</span>
<span id="cb18-25"><a href="#cb18-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-26"><a href="#cb18-26" aria-hidden="true" tabindex="-1"></a><span class="co"># Draw the level set F = 1 (ellipse)</span></span>
<span id="cb18-27"><a href="#cb18-27" aria-hidden="true" tabindex="-1"></a>plt.contour(X, Y, F, levels<span class="op">=</span>[<span class="dv">1</span>], colors<span class="op">=</span><span class="st">'blue'</span>)</span>
<span id="cb18-28"><a href="#cb18-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-29"><a href="#cb18-29" aria-hidden="true" tabindex="-1"></a><span class="co"># Draw eigenvectors scaled by semi-axis lengths</span></span>
<span id="cb18-30"><a href="#cb18-30" aria-hidden="true" tabindex="-1"></a>axis1 <span class="op">=</span> v1 <span class="op">/</span> np.sqrt(eigvals[<span class="dv">0</span>])</span>
<span id="cb18-31"><a href="#cb18-31" aria-hidden="true" tabindex="-1"></a>axis2 <span class="op">=</span> v2 <span class="op">/</span> np.sqrt(eigvals[<span class="dv">1</span>])</span>
<span id="cb18-32"><a href="#cb18-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-33"><a href="#cb18-33" aria-hidden="true" tabindex="-1"></a>plt.quiver(<span class="dv">0</span>, <span class="dv">0</span>, axis1[<span class="dv">0</span>], axis1[<span class="dv">1</span>], angles<span class="op">=</span><span class="st">'xy'</span>, scale_units<span class="op">=</span><span class="st">'xy'</span>, scale<span class="op">=</span><span class="dv">1</span>, color<span class="op">=</span><span class="st">'red'</span>, label<span class="op">=</span><span class="ss">f'Axis 1 (λ=</span><span class="sc">{</span>eigvals[<span class="dv">0</span>]<span class="sc">:.2f}</span><span class="ss">)'</span>)</span>
<span id="cb18-34"><a href="#cb18-34" aria-hidden="true" tabindex="-1"></a>plt.quiver(<span class="dv">0</span>, <span class="dv">0</span>, <span class="op">-</span>axis1[<span class="dv">0</span>], <span class="op">-</span>axis1[<span class="dv">1</span>], angles<span class="op">=</span><span class="st">'xy'</span>, scale_units<span class="op">=</span><span class="st">'xy'</span>, scale<span class="op">=</span><span class="dv">1</span>, color<span class="op">=</span><span class="st">'red'</span>)</span>
<span id="cb18-35"><a href="#cb18-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-36"><a href="#cb18-36" aria-hidden="true" tabindex="-1"></a>plt.quiver(<span class="dv">0</span>, <span class="dv">0</span>, axis2[<span class="dv">0</span>], axis2[<span class="dv">1</span>], angles<span class="op">=</span><span class="st">'xy'</span>, scale_units<span class="op">=</span><span class="st">'xy'</span>, scale<span class="op">=</span><span class="dv">1</span>, color<span class="op">=</span><span class="st">'red'</span>, label<span class="op">=</span><span class="ss">f'Axis 2 (λ=</span><span class="sc">{</span>eigvals[<span class="dv">1</span>]<span class="sc">:.2f}</span><span class="ss">)'</span>)</span>
<span id="cb18-37"><a href="#cb18-37" aria-hidden="true" tabindex="-1"></a>plt.quiver(<span class="dv">0</span>, <span class="dv">0</span>, <span class="op">-</span>axis2[<span class="dv">0</span>], <span class="op">-</span>axis2[<span class="dv">1</span>], angles<span class="op">=</span><span class="st">'xy'</span>, scale_units<span class="op">=</span><span class="st">'xy'</span>, scale<span class="op">=</span><span class="dv">1</span>, color<span class="op">=</span><span class="st">'red'</span>)</span>
<span id="cb18-38"><a href="#cb18-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-39"><a href="#cb18-39" aria-hidden="true" tabindex="-1"></a><span class="co"># Formatting</span></span>
<span id="cb18-40"><a href="#cb18-40" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Principal Axes of a Quadratic Form'</span>)</span>
<span id="cb18-41"><a href="#cb18-41" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'x'</span>)</span>
<span id="cb18-42"><a href="#cb18-42" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'y'</span>)</span>
<span id="cb18-43"><a href="#cb18-43" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb18-44"><a href="#cb18-44" aria-hidden="true" tabindex="-1"></a>plt.axhline(<span class="dv">0</span>, color<span class="op">=</span><span class="st">'black'</span>, linewidth<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb18-45"><a href="#cb18-45" aria-hidden="true" tabindex="-1"></a>plt.axvline(<span class="dv">0</span>, color<span class="op">=</span><span class="st">'black'</span>, linewidth<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb18-46"><a href="#cb18-46" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb18-47"><a href="#cb18-47" aria-hidden="true" tabindex="-1"></a>plt.axis(<span class="st">'equal'</span>)</span>
<span id="cb18-48"><a href="#cb18-48" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div id="fig-quadratic-form" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-quadratic-form-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="module2_files/figure-html/fig-quadratic-form-output-1.png" width="609" height="597" class="figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-quadratic-form-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3.2: The ellipse defined by the quadratic form. The eigenvectors (red) point along the major and minor axes.
</figcaption>
</figure>
</div>
</div>
</div>
<p>The plot shows it perfectly. The quadratic form describes a rotated ellipse, and the eigenvectors of the associated symmetric matrix point exactly along its major and minor axes. The signs of the eigenvalues (<span class="math inline">\(\lambda_1=5, \lambda_2=-1\)</span>) tell us it’s a hyperbola (one positive, one negative), not an ellipse. My description was slightly off, but the math and the plot reveal the truth! This is why we do the computation.</p>
</section>
<section id="tutorial-4-principal-axis-transformation-of-quadratic-forms" class="level2" data-number="3.8">
<h2 data-number="3.8" class="anchored" data-anchor-id="tutorial-4-principal-axis-transformation-of-quadratic-forms"><span class="header-section-number">3.8</span> Tutorial 4: Principal Axis Transformation of Quadratic Forms</h2>
<ol type="1">
<li>Step 1: Write the quadratic form in <span class="math inline">\(X^TAX = c\)</span> form and compute eigenvalues/eigenvectors of <span class="math inline">\(A\)</span>.<br>
</li>
<li>Step 2: Construct the modal matrix <span class="math inline">\(B\)</span>, compute <span class="math inline">\(B^{-1}\)</span>, and form normalized modal matrix <span class="math inline">\(\hat{B}\)</span>.<br>
</li>
<li>Step 3: Write orthogonal transformation <span class="math inline">\(X = \hat{B}Y\)</span>.<br>
</li>
<li>Step 4: Express the quadratic form in principal axis form with numeric eigenvalues.<br>
</li>
<li>Step 5: Express <span class="math inline">\(Y = B^{-1}X\)</span> with numeric coefficients.</li>
</ol>
<hr>
<p><strong>Problem 1:</strong> The energy stored in a coupled capacitor system is given by: <span class="math display">\[
5x_1^{2}+4x_1x_2+3x_2^{2}=10
\]</span> Transform to principal-axis form, find the orthogonal transformation <span class="math inline">\(X=\hat{B}Y\)</span>, classify the conic, and give <span class="math inline">\(Y=B^{-1}X\)</span>.</p>
<p><strong>Solution:</strong></p>
<p><strong>Step 1:</strong> <span class="math inline">\(A = \begin{bmatrix}5 &amp; 2\\2 &amp; 3\end{bmatrix}\)</span></p>
<p>Eigenvalues: <span class="math inline">\(\lambda_1 = 6.236\)</span>, <span class="math inline">\(\lambda_2 = 1.764\)</span></p>
<p>Eigenvectors:<br>
<span class="math inline">\(v_1 = \begin{pmatrix}3.236\\2\end{pmatrix}\)</span>, <span class="math inline">\(v_2 = \begin{pmatrix}-1.236\\2\end{pmatrix}\)</span></p>
<p><strong>Step 2:</strong> Modal matrix <span class="math inline">\(B = \begin{bmatrix}3.236 &amp; -1.236\\2 &amp; 2\end{bmatrix}\)</span><br>
Normalized modal matrix:</p>
<p><span class="math display">\[
\hat{B} = \begin{bmatrix}0.853 &amp; -0.525\\0.527 &amp; 0.850\end{bmatrix}
\]</span></p>
<p><strong>Step 3:</strong> Orthogonal transformation: <span class="math inline">\(X = \hat{B}Y\)</span></p>
<p><strong>Step 4:</strong> Principal axis form:</p>
<p><span class="math display">\[
6.236 y_1^2 + 1.764 y_2^2 = 10
\]</span></p>
<p><strong>Step 5:</strong> Inverse transformation:</p>
<p><span class="math display">\[
Y = B^{-1}X =
\begin{bmatrix}
0.359 x_1 + 0.222 x_2\\
-0.251 x_1 + 0.591 x_2
\end{bmatrix}
\]</span></p>
<p>Classification: <strong>ellipse</strong></p>
<hr>
<p><strong>Problem 2:</strong> The spread of pixel intensity in an image block is modeled by:</p>
<p><span class="math display">\[
4x_1^{2}-6x_1x_2+9x_2^{2}=36
\]</span></p>
<p>Transform to principal axis form, find the orthogonal transformation, classify the conic, and write <span class="math inline">\(Y=B^{-1}X\)</span>.</p>
<p><strong>Solution:</strong></p>
<p><strong>Step 1:</strong> <span class="math inline">\(A = \begin{bmatrix}4 &amp; -3\\-3 &amp; 9\end{bmatrix}\)</span></p>
<p>Eigenvalues: <span class="math inline">\(\lambda_1 = 10.405\)</span>, <span class="math inline">\(\lambda_2 = 2.595\)</span></p>
<p>Eigenvectors: <span class="math inline">\(v_1 = \begin{pmatrix}1.405\\-3\end{pmatrix}\)</span>, <span class="math inline">\(v_2 = \begin{pmatrix}-6.405\\-3\end{pmatrix}\)</span></p>
<p><strong>Step 2:</strong> Modal matrix <span class="math inline">\(B = [v_1\ v_2]\)</span><br>
Normalized modal matrix:</p>
<p><span class="math display">\[
\hat{B} = \begin{bmatrix}0.421 &amp; -0.894\\ -0.907 &amp; -0.447\end{bmatrix}
\]</span></p>
<p><strong>Step 3:</strong> <span class="math inline">\(X = \hat{B}Y\)</span></p>
<p><strong>Step 4:</strong> Principal axis form:</p>
<p><span class="math display">\[
10.405 y_1^2 + 2.595 y_2^2 = 36
\]</span></p>
<p><strong>Step 5:</strong> Inverse transformation:</p>
<p><span class="math display">\[
Y = B^{-1}X =
\begin{bmatrix}
0.404 x_1 - 0.172 x_2\\
0.865 x_1 + 0.177 x_2
\end{bmatrix}
\]</span></p>
<p>Classification: <strong>ellipse</strong></p>
<hr>
<p><strong>Problem 3:</strong> The potential energy of a 3-mass vibrating system is given by:<br>
<span class="math display">\[
6x_1^{2}+4x_1x_2+3x_2^{2}+2x_2x_3+2x_3^{2}=20
\]</span></p>
<p>Transform to principal axis form, find the orthogonal transformation, classify the quadric surface, and write <span class="math inline">\(Y=B^{-1}X\)</span>.</p>
<p><strong>Solution:</strong></p>
<p><strong>Step 1:</strong> <span class="math inline">\(A = \begin{bmatrix}6 &amp; 2 &amp; 0\\2 &amp; 3 &amp; 1\\0 &amp; 1 &amp; 2\end{bmatrix}\)</span></p>
<p>Eigenvalues: <span class="math inline">\(\lambda_1 = 7.541\)</span>, <span class="math inline">\(\lambda_2 = 2.459\)</span>, <span class="math inline">\(\lambda_3 = 1.0\)</span></p>
<p>Eigenvectors (normalized):<br>
<span class="math inline">\(v_1 = \begin{pmatrix}0.814\\0.556\\0.166\end{pmatrix}\)</span>,<br>
<span class="math inline">\(v_2 = \begin{pmatrix}-0.576\\0.817\\-0.056\end{pmatrix}\)</span>,<br>
<span class="math inline">\(v_3 = \begin{pmatrix}-0.062\\-0.156\\0.986\end{pmatrix}\)</span></p>
<p><strong>Step 2:</strong> Modal matrix <span class="math inline">\(B = [v_1\ v_2\ v_3]\)</span></p>
<p><span class="math display">\[
B =
\begin{bmatrix}
0.814 &amp; -0.576 &amp; -0.062\\
0.556 &amp; 0.817 &amp; -0.156\\
0.166 &amp; -0.056 &amp; 0.986
\end{bmatrix}, \quad B^{-1} \approx B^T
\]</span></p>
<p>Normalized modal matrix: <span class="math inline">\(\hat{B} = B\)</span></p>
<p><strong>Step 3:</strong> <span class="math inline">\(X = \hat{B}Y\)</span></p>
<p><strong>Step 4:</strong> Principal axis form:</p>
<p><span class="math display">\[
7.541 y_1^2 + 2.459 y_2^2 + 1.0 y_3^2 = 20
\]</span></p>
<p><strong>Step 5:</strong> Inverse transformation:</p>
<p><span class="math display">\[
\begin{bmatrix}y_1\\y_2\\y_3\end{bmatrix} =
B^{-1} X \approx
\begin{bmatrix}
0.814 &amp; 0.556 &amp; 0.166\\
-0.576 &amp; 0.817 &amp; -0.056\\
-0.062 &amp; -0.156 &amp; 0.986
\end{bmatrix}
\begin{bmatrix}x_1\\x_2\\x_3\end{bmatrix}
\]</span></p>
<p>Classification: All positive eigenvalues <span class="math inline">\(\Rightarrow\)</span> <strong>ellipsoid</strong></p>
<hr>
<p><strong>Problem 4:</strong> A quadratic classifier is modeled by: <span class="math display">\[
2x_1^{2}+2x_1x_2+2x_2^{2}=8
\]</span></p>
<p>Reduce to principal axis form, find the orthogonal transformation, classify the conic, and write <span class="math inline">\(Y=B^{-1}X\)</span>.</p>
<p><strong>Solution:</strong></p>
<p><strong>Step 1:</strong> <span class="math inline">\(A = \begin{bmatrix}2 &amp; 1\\1 &amp; 2\end{bmatrix}\)</span></p>
<p>Eigenvalues: <span class="math inline">\(\lambda_1 = 3\)</span>, <span class="math inline">\(\lambda_2 = 1\)</span></p>
<p>Eigenvectors using formula: <span class="math inline">\(v_1 = \begin{pmatrix}1\\1\end{pmatrix}\)</span>, <span class="math inline">\(v_2 = \begin{pmatrix}-1\\1\end{pmatrix}\)</span></p>
<p><strong>Step 2:</strong> Modal matrix <span class="math inline">\(B = [v_1\ v_2]\)</span>, normalized:</p>
<p><span class="math display">\[
\hat{B} = \frac{1}{\sqrt{2}}\begin{bmatrix}1 &amp; -1\\1 &amp; 1\end{bmatrix}
\]</span></p>
<p><strong>Step 3:</strong> <span class="math inline">\(X = \hat{B}Y\)</span></p>
<p><strong>Step 4:</strong> Principal axis form:</p>
<p><span class="math display">\[
3 y_1^2 + 1 y_2^2 = 8
\]</span></p>
<p><strong>Step 5:</strong> Inverse transformation:</p>
<p><span class="math display">\[
Y = B^{-1}X = \frac{1}{2}\begin{bmatrix}1 &amp; 1\\-1 &amp; 1\end{bmatrix}\begin{bmatrix}x_1\\x_2\end{bmatrix} =
\begin{bmatrix}\frac{x_1 + x_2}{2}\\ \frac{-x_1 + x_2}{2}\end{bmatrix}
\]</span></p>
<p>Classification: <strong>ellipse</strong></p>
<hr>
<p><strong>Problem 5:</strong> A Lyapunov function candidate is: <span class="math display">\[
7x_1^{2}-4x_1x_2+4x_2^{2}+2x_2x_3+3x_3^{2}=15
\]</span></p>
<p>Transform to principal axis form, find the orthogonal transformation, determine stability, and write <span class="math inline">\(Y=B^{-1}X\)</span>.</p>
<p><strong>Solution:</strong></p>
<p><strong>Step 1:</strong> <span class="math inline">\(A = \begin{bmatrix}7 &amp; -2 &amp; 0\\-2 &amp; 4 &amp; 1\\0 &amp; 1 &amp; 3\end{bmatrix}\)</span></p>
<p>Eigenvalues: <span class="math inline">\(\lambda_1 = 8.061\)</span>, <span class="math inline">\(\lambda_2 = 3.0\)</span>, <span class="math inline">\(\lambda_3 = 2.939\)</span></p>
<p>Eigenvectors (normalized):<br>
<span class="math inline">\(v_1 = \begin{pmatrix}0.872\\-0.441\\0.207\end{pmatrix}\)</span>,<br>
<span class="math inline">\(v_2 = \begin{pmatrix}-0.308\\0.886\\-0.345\end{pmatrix}\)</span>,<br>
<span class="math inline">\(v_3 = \begin{pmatrix}0.379\\0.153\\0.912\end{pmatrix}\)</span></p>
<p><strong>Step 2:</strong> Modal matrix <span class="math inline">\(B = [v_1\ v_2\ v_3]\)</span>, <span class="math inline">\(\hat{B} = B\)</span>, <span class="math inline">\(B^{-1} \approx B^T\)</span></p>
<p><strong>Step 3:</strong> <span class="math inline">\(X = \hat{B}Y\)</span></p>
<p><strong>Step 4:</strong> Principal axis form:</p>
<p><span class="math display">\[
8.061 y_1^2 + 3.0 y_2^2 + 2.939 y_3^2 = 15
\]</span></p>
<p><strong>Step 5:</strong> Inverse transformation:</p>
<p><span class="math display">\[
Y = B^{-1} X \approx
\begin{bmatrix}
0.872 &amp; -0.441 &amp; 0.207\\
-0.308 &amp; 0.886 &amp; -0.345\\
0.379 &amp; 0.153 &amp; 0.912
\end{bmatrix}
\begin{bmatrix}x_1\\x_2\\x_3\end{bmatrix}
\]</span></p>
<p>Classification: All eigenvalues positive <span class="math inline">\(\Rightarrow\)</span> <strong>stable system</strong></p>
<hr>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Interpretation of the sign of eigenvalues and the nature of normalized modal matrix in terms of stability
</div>
</div>
<div class="callout-body-container callout-body">
<p>The orthogonal modal transformation <span class="math inline">\(X=\hat{B}Y\)</span> rotates (and possibly reflects) the coordinate axes to align with the eigen-directions of <span class="math inline">\(A\)</span>. This eliminates cross-terms (interaction terms) and diagonalizes the quadratic form. Because <span class="math inline">\(\hat{B}\)</span> is orthonormal, it preserves quadratic quantities such as energy and definiteness: eigenvalue signs therefore directly determine the type of conic/quadric and stability. The transformed coordinates <span class="math inline">\(y_i\)</span> are independent modal contributions scaled by the eigenvalues.</p>
</div>
</div>
</section>
<section id="module-ii-summary" class="level2" data-number="3.9">
<h2 data-number="3.9" class="anchored" data-anchor-id="module-ii-summary"><span class="header-section-number">3.9</span> Module II Summary</h2>
<ul>
<li>The core idea of this module is the equation <span class="math inline">\(Ax = \lambda x\)</span>.</li>
<li><strong>Eigenvectors</strong> (<span class="math inline">\(x\)</span>) are the special directions for a matrix that are only scaled, not rotated. <strong>Eigenvalues</strong> (<span class="math inline">\(\lambda\)</span>) are the scaling factors.</li>
<li>We find eigenvalues by solving the <strong>characteristic equation</strong> <span class="math inline">\(\det(A - \lambda I) = 0\)</span>.</li>
<li><strong>Diagonalization</strong> (<span class="math inline">\(A = S \Lambda S^{-1}\)</span>) is a powerful tool that simplifies matrix powers and reveals the true nature of a transformation.</li>
<li><strong>Symmetric matrices</strong> are the nicest of all, with real eigenvalues and orthogonal eigenvectors, leading to the decomposition <span class="math inline">\(A = Q \Lambda Q^T\)</span>.</li>
<li>This theory has direct applications in geometry, such as finding the principal axes of shapes defined by <strong>quadratic forms</strong>.</li>
</ul>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./module1.html" class="pagination-link" aria-label="Module-1: Linear Systems, Properties, and its Solution">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Module-1: Linear Systems, Properties, and its Solution</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./module3.html" class="pagination-link" aria-label="Module 3: Multivariable Calculus - Differentiation">
        <span class="nav-page-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Module 3: Multivariable Calculus - Differentiation</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>